package imageprocessing;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 *
 * @author චානක මධුරංග
 */
public class Image extends javax.swing.JFrame {

    JFileChooser filechooser;
    BufferedImage image = null;
    BufferedImage tempImage = null;
    int imageWidth = 0;
    int imageHeight = 0;

    int tempImageHeight = 0;
    int tempImageWidth = 0;
    HashMap<Integer, String> outputHashMapWithSymbols;

    public Image() {

        initComponents();

        filechooser = new JFileChooser("C:\\Users\\Chanaka\\Desktop");
        filechooser.addChoosableFileFilter(new FileNameExtensionFilter("JPG", "JPG", "JPEG"));
        filechooser.addChoosableFileFilter(new FileNameExtensionFilter("PNG", "PNG"));
        filechooser.addChoosableFileFilter(new FileNameExtensionFilter("GIF", "GIF"));
        filechooser.addChoosableFileFilter(new FileNameExtensionFilter("130281M", "130281M"));

      /*  //delete below later
        try {
            image = ImageIO.read(new File("C:\\Users\\Chanaka\\Desktop\\fb.jpg"));
            drawImage();
            calculateDeviations(jTable1);
        } catch (Exception e) {
            System.out.println("Erroreee");
        }//till */
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jLabel2 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jButton6 = new javax.swing.JButton();
        jButton8 = new javax.swing.JButton();
        jButton9 = new javax.swing.JButton();
        jButton7 = new javax.swing.JButton();
        jButton5 = new javax.swing.JButton();
        jButton10 = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTable2 = new javax.swing.JTable();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setExtendedState(JFrame.MAXIMIZED_BOTH);
        setLocation(new java.awt.Point(0, 0));
        addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                formPropertyChange(evt);
            }
        });

        jScrollPane1.setMinimumSize(new java.awt.Dimension(0, 0));

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jScrollPane1.setViewportView(jLabel1);

        jScrollPane2.setMinimumSize(new java.awt.Dimension(0, 0));

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jScrollPane2.setViewportView(jLabel2);

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jButton1.setText("Gray Scale (Average)");
        jButton1.setMaximumSize(new java.awt.Dimension(115, 23));
        jButton1.setMinimumSize(new java.awt.Dimension(115, 23));
        jButton1.setPreferredSize(new java.awt.Dimension(115, 23));
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("Gray Scale (Best)");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton3.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jButton3.setText("Apply Changes");
        jButton3.setMaximumSize(new java.awt.Dimension(115, 23));
        jButton3.setMinimumSize(new java.awt.Dimension(115, 23));
        jButton3.setPreferredSize(new java.awt.Dimension(115, 23));
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jButton4.setText("Save (24bit)");
        jButton4.setMaximumSize(new java.awt.Dimension(115, 23));
        jButton4.setMinimumSize(new java.awt.Dimension(115, 23));
        jButton4.setPreferredSize(new java.awt.Dimension(115, 23));
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jButton6.setText("Save (8bit)");
        jButton6.setMaximumSize(new java.awt.Dimension(115, 23));
        jButton6.setMinimumSize(new java.awt.Dimension(115, 23));
        jButton6.setPreferredSize(new java.awt.Dimension(115, 23));
        jButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton6ActionPerformed(evt);
            }
        });

        jButton8.setText("Scale Down (0.5x)");
        jButton8.setMaximumSize(new java.awt.Dimension(115, 23));
        jButton8.setMinimumSize(new java.awt.Dimension(115, 23));
        jButton8.setPreferredSize(new java.awt.Dimension(115, 23));
        jButton8.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton8ActionPerformed(evt);
            }
        });

        jButton9.setText("Scale Up (2x)");
        jButton9.setMaximumSize(new java.awt.Dimension(115, 23));
        jButton9.setMinimumSize(new java.awt.Dimension(115, 23));
        jButton9.setPreferredSize(new java.awt.Dimension(115, 23));
        jButton9.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton9ActionPerformed(evt);
            }
        });

        jButton7.setText("Calculate Deviations");
        jButton7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton7ActionPerformed(evt);
            }
        });

        jButton5.setText("Huffman");
        jButton5.setMaximumSize(new java.awt.Dimension(115, 23));
        jButton5.setMinimumSize(new java.awt.Dimension(115, 23));
        jButton5.setPreferredSize(new java.awt.Dimension(115, 23));
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });

        jButton10.setText("Run Length");
        jButton10.setMaximumSize(new java.awt.Dimension(115, 23));
        jButton10.setMinimumSize(new java.awt.Dimension(115, 23));
        jButton10.setPreferredSize(new java.awt.Dimension(115, 23));
        jButton10.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton10ActionPerformed(evt);
            }
        });

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Deviation", "Red", "Green", "Blue"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane3.setViewportView(jTable1);
        if (jTable1.getColumnModel().getColumnCount() > 0) {
            jTable1.getColumnModel().getColumn(0).setResizable(false);
            jTable1.getColumnModel().getColumn(1).setResizable(false);
            jTable1.getColumnModel().getColumn(2).setResizable(false);
            jTable1.getColumnModel().getColumn(3).setResizable(false);
        }

        jTable2.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Deviation", "Red", "Green", "Blue"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane4.setViewportView(jTable2);
        if (jTable2.getColumnModel().getColumnCount() > 0) {
            jTable2.getColumnModel().getColumn(0).setResizable(false);
            jTable2.getColumnModel().getColumn(1).setResizable(false);
            jTable2.getColumnModel().getColumn(2).setResizable(false);
            jTable2.getColumnModel().getColumn(3).setResizable(false);
        }

        jLabel3.setText("Original Image");

        jLabel4.setText("Edited Image");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton7, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jButton5, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 255, Short.MAX_VALUE)
                            .addComponent(jButton4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton8, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButton2, javax.swing.GroupLayout.DEFAULT_SIZE, 256, Short.MAX_VALUE)
                            .addComponent(jButton9, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton10, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addComponent(jButton3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(25, 25, 25)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel4)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 725, Short.MAX_VALUE)
                        .addComponent(jScrollPane4))
                    .addComponent(jLabel3)))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(5, 5, 5)
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButton4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButton9, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton8, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButton5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton10, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel4))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addGap(30, 30, 30)
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE))))
        );

        jMenu1.setText("File");

        jMenuItem1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem1.setText("Open");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem1);

        jMenuItem2.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem2.setText("Save");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem2);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");
        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 632, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 633, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 268, Short.MAX_VALUE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        if (filechooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                image = ImageIO.read(filechooser.getSelectedFile());
                drawImage();
                calculateDeviations(jTable1);
            } catch (NullPointerException ex) {
                open_tt_files(filechooser.getSelectedFile().toPath());
                calculateDeviations(jTable1);
            } catch (IOException e) {
                JOptionPane.showMessageDialog(filechooser, "This is not an image!", "Error", JOptionPane.WARNING_MESSAGE);
            }

        }
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void formPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_formPropertyChange

    }//GEN-LAST:event_formPropertyChange

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        if (filechooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            String newImageExtention = filechooser.getFileFilter().getDescription();

            File newImagePath = new File(filechooser.getSelectedFile().toString() + "." + newImageExtention);
            try {
                ImageIO.write(image, newImageExtention, newImagePath);
            } catch (IOException ex) {
                Logger.getLogger(Image.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        if (image == null) {
            System.out.println("Load Image...");
        } else {
            ConvertToGrayUsingAverage();
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        if (image == null) {
            System.out.println("Load Image...");
        } else {
            convertToGrayUsingConstants();
        }

    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        if (tempImage == null) {
        } else {
            image = tempImage;
            drawImage();
        }
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        save4bytePixel();
    }//GEN-LAST:event_jButton4ActionPerformed

    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton6ActionPerformed
        save1bytePixel();
    }//GEN-LAST:event_jButton6ActionPerformed

    private void jButton8ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton8ActionPerformed
        ScaleDown_halfx_UsingBilinearInterpolation(imageWidth / 2, imageHeight / 2);
    }//GEN-LAST:event_jButton8ActionPerformed

    private void jButton9ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton9ActionPerformed
        scaleUp_2x_UsingNearestNeighborMethod();
    }//GEN-LAST:event_jButton9ActionPerformed

    private void jButton7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton7ActionPerformed
        calculateDeviations(jTable2);
    }//GEN-LAST:event_jButton7ActionPerformed

    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed
        SaveUsingHuffmanSymbols();//this saves the image using Huffmann coding
    }//GEN-LAST:event_jButton5ActionPerformed

    private void jButton10ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton10ActionPerformed

    }//GEN-LAST:event_jButton10ActionPerformed

    //Task 2 - Convert to gray scale using average method
    public void ConvertToGrayUsingAverage() {//Done
        tempImage = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);
        tempImageWidth = tempImage.getWidth();
        tempImageHeight = tempImage.getHeight();
        for (int i = 0; i < imageHeight; i++) {
            for (int j = 0; j < imageWidth; j++) {
                Color color = new Color(image.getRGB(j, i));
                int avg = (color.getRed() + color.getGreen() + color.getBlue()) / 3;//calculate the average
                int grayValue = new Color(avg, avg, avg, 255).getRGB();
                tempImage.setRGB(j, i, grayValue);
            }
        }
        jLabel2.setSize(tempImageWidth, tempImageHeight);
        jLabel2.setIcon(new ImageIcon(tempImage));
    }

    //Task 2 - Convert to gray scale using Luminance preserving method
    public void convertToGrayUsingConstants() {//Done
        tempImage = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);//new
        tempImageWidth = tempImage.getWidth();
        tempImageHeight = tempImage.getHeight();
        for (int i = 0; i < imageHeight; i++) {
            for (int j = 0; j < imageWidth; j++) {
                Color color = new Color(image.getRGB(j, i));
                int avg = (int) ((0.2126 * color.getRed()) + (0.7152 * color.getGreen()) + (0.0722 * color.getBlue()));//calculate the value
                int grayValue = new Color(avg, avg, avg, 255).getRGB();
                tempImage.setRGB(j, i, grayValue);
            }
        }
        jLabel2.setSize(tempImageWidth, tempImageHeight);
        jLabel2.setIcon(new ImageIcon(tempImage));
    }

    //For saving 24bit format
    void save4bytePixel() {
        byte[] byteArray = new byte[(imageHeight * imageWidth * 3) + 8];
        byte[] width = ByteBuffer.allocate(4).putInt(imageWidth).array();//store width
        byte[] height = ByteBuffer.allocate(4).putInt(imageHeight).array();//store height

        for (int i = 0; i < 4; i++) {
            byteArray[i] = width[i];
            byteArray[i + 4] = height[i];
        }

        //store colour details of each pixel
        int p = 8;
        for (int i = 0; i < imageHeight; i++) {
            for (int j = 0; j < imageWidth; j++) {
                Color color = new Color(image.getRGB(j, i));
                byteArray[p] = (byte) (color.getRed() - 128);
                byteArray[p + 1] = (byte) (color.getGreen() - 128);
                byteArray[p + 2] = (byte) (color.getBlue() - 128);
                p = p + 3;
            }
        }

        if (filechooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File newImagePath = new File(filechooser.getSelectedFile().toString() + ".130281M");
            try {
                FileOutputStream fos = new FileOutputStream(newImagePath);
                fos.write(byteArray);
                fos.close();
            } catch (IOException ex) {
                Logger.getLogger(Image.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    //For opening 24bit format
    void open4bytePixel(Path filePath) {
        try {
            byte[] byteArray = Files.readAllBytes(filePath);
            int width = ByteBuffer.wrap(Arrays.copyOfRange(byteArray, 0, 4)).getInt();
            int height = ByteBuffer.wrap(Arrays.copyOfRange(byteArray, 4, 8)).getInt();
            BufferedImage anImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
            int p = 8;
            for (int i = 0; i < height; i++) {
                for (int j = 0; j < width; j++) {
                    anImage.setRGB(j, i, new Color(byteArray[p] + 128, byteArray[p + 1] + 128, byteArray[p + 2] + 128, 255).getRGB());
                    p = p + 3;
                }
            }
            image = anImage;
            drawImage();

        } catch (IOException ex) {
            Logger.getLogger(Image.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    //Task 2 - for saving 8bit format
    void save1bytePixel() {
        byte[] byteArray = new byte[(imageHeight * imageWidth) + 8];
        byte[] width = ByteBuffer.allocate(4).putInt(imageWidth).array();
        byte[] height = ByteBuffer.allocate(4).putInt(imageHeight).array();

        for (int i = 0; i < 4; i++) {
            byteArray[i] = width[i];
            byteArray[i + 4] = height[i];
        }

        int p = 8;
        for (int i = 0; i < imageHeight; i++) {
            for (int j = 0; j < imageWidth; j++) {
                Color color = new Color(image.getRGB(j, i));
                byteArray[p] = (byte) (color.getRed() - 128);
                p++;
            }
        }

        if (filechooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File newImagePath = new File(filechooser.getSelectedFile().toString() + ".130281M");
            try {
                FileOutputStream fos = new FileOutputStream(newImagePath);
                fos.write(byteArray);
                fos.close();
            } catch (IOException ex) {
                Logger.getLogger(Image.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    //Task 2 - for opening 8bit format
    void open1bytePixel(Path filePath) {
        try {
            byte[] byteArray = Files.readAllBytes(filePath);
            int width = ByteBuffer.wrap(Arrays.copyOfRange(byteArray, 0, 4)).getInt();
            int height = ByteBuffer.wrap(Arrays.copyOfRange(byteArray, 4, 8)).getInt();
            BufferedImage anImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
            int p = 8;
            for (int i = 0; i < height; i++) {
                for (int j = 0; j < width; j++) {
                    int colour = byteArray[p] + 128;
                    anImage.setRGB(j, i, new Color(colour, colour, colour, 255).getRGB());
                    p++;
                }
            }
            image = anImage;
            drawImage();

        } catch (IOException ex) {
            Logger.getLogger(Image.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    //Task 3 - Scale down (Bilinear interpolation)
    public void ScaleDown_halfx_UsingBilinearInterpolation(int w2, int h2) {
        tempImage = new BufferedImage(w2, h2, BufferedImage.TYPE_INT_RGB);

        double ratioX = ((double) (imageWidth - 1)) / w2;
        double ratioY = ((double) (imageHeight - 1)) / h2;
        double differenceX, differenceY;

        for (int i = 0; i < h2; i++) {
            for (int j = 0; j < w2; j++) {
                int x = (int) (ratioX * j);
                int y = (int) (ratioY * i);
                differenceX = (ratioX * j) - x;
                differenceY = (ratioY * i) - y;

                Color leftUp = new Color(image.getRGB(x, y));
                Color rightUp = new Color(image.getRGB(x + 1, y));
                Color leftDown = new Color(image.getRGB(x, y + 1));
                Color rightDown = new Color(image.getRGB(x + 1, y + 1));

                int blue = (int) (leftUp.getBlue() * (1 - differenceX) * (1 - differenceY)
                        + rightUp.getBlue() * differenceX * (1 - differenceY)
                        + leftDown.getBlue() * (1 - differenceX) * differenceY
                        + rightDown.getBlue() * differenceX * differenceY);

                int green = (int) (leftUp.getGreen() * (1 - differenceX) * (1 - differenceY)
                        + rightUp.getGreen() * differenceX * (1 - differenceY)
                        + leftDown.getGreen() * (1 - differenceX) * differenceY
                        + rightDown.getGreen() * differenceX * differenceY);

                int red = (int) (leftUp.getRed() * (1 - differenceX) * (1 - differenceY)
                        + rightUp.getRed() * differenceX * (1 - differenceY)
                        + leftDown.getRed() * (1 - differenceX) * differenceY
                        + rightDown.getRed() * differenceX * differenceY);

                tempImage.setRGB(j, i, new Color(red, green, blue, 255).getRGB());

                jLabel2.setSize(w2, h2);
                jLabel2.setIcon(new ImageIcon(tempImage));
            }
        }
    }

    //Task 3 - Scale up (Nearest Neighbor)
    public void scaleUp_2x_UsingNearestNeighborMethod() {

        tempImageHeight = imageHeight * 2;
        tempImageWidth = imageWidth * 2;
        tempImage = new BufferedImage(tempImageWidth, tempImageHeight, BufferedImage.TYPE_INT_RGB);

        for (int i = 0; i < tempImageHeight; i++) {
            for (int j = 0; j < tempImageWidth; j++) {
                tempImage.setRGB(j, i, image.getRGB(j / 2, i / 2));
            }
        }

        jLabel2.setSize(tempImageWidth, tempImageWidth);
        jLabel2.setIcon(new ImageIcon(tempImage));
    }

    //Task 4 - Calculate standard deviation and average deviation
    public void calculateDeviations(JTable table) {

        //first calculate the mean
        double redSum = 0;
        double greenSum = 0;
        double blueSum = 0;
        for (int i = 0; i < imageHeight; i++) {
            for (int j = 0; j < imageWidth; j++) {
                redSum = redSum + new Color(image.getRGB(j, i)).getRed();
                greenSum = greenSum + new Color(image.getRGB(j, i)).getGreen();
                blueSum = blueSum + new Color(image.getRGB(j, i)).getBlue();
            }
        }
        int sum = imageWidth * imageHeight;
        double redMean = redSum / sum;
        double greenMean = greenSum / sum;
        double blueMean = blueSum / sum;

        double redAverageDeviationSum = 0;
        double redVarianceSum = 0;

        double greenAverageDeviationSum = 0;
        double greenVarianceSum = 0;

        double blueAverageDeviationSum = 0;
        double blueVarianceSum = 0;

        for (int i = 0; i < imageHeight; i++) {
            for (int j = 0; j < imageWidth; j++) {
                Color colour = new Color(image.getRGB(j, i));

                int redValue = colour.getRed();
                redAverageDeviationSum = redAverageDeviationSum + Math.abs(redValue - redMean);
                redVarianceSum = redVarianceSum + Math.pow(redValue - redMean, 2);

                int greenValue = colour.getGreen();
                greenAverageDeviationSum = greenAverageDeviationSum + Math.abs(greenValue - greenMean);
                greenVarianceSum = greenVarianceSum + Math.pow(greenValue - greenMean, 2);

                int blueValue = colour.getBlue();
                blueAverageDeviationSum = blueAverageDeviationSum + Math.abs(blueValue - blueMean);
                blueVarianceSum = blueVarianceSum + Math.pow(blueValue - blueMean, 2);
            }
        }

        double redAverageDeviation = redAverageDeviationSum / sum;
        double redStandardDeviation = Math.sqrt(redVarianceSum / sum);

        double greenAverageDeviation = greenAverageDeviationSum / sum;
        double greenStandardDeviation = Math.sqrt(greenVarianceSum / sum);

        double blueAverageDeviation = blueAverageDeviationSum / sum;
        double blueStandardDeviation = Math.sqrt(blueVarianceSum / sum);

        table.setValueAt("Average Deviation", 0, 0);
        table.setValueAt(redAverageDeviation, 0, 1);
        table.setValueAt(greenAverageDeviation, 0, 2);
        table.setValueAt(blueAverageDeviation, 0, 3);

        table.setValueAt("Standard Deviation", 1, 0);
        table.setValueAt(redStandardDeviation, 1, 1);
        table.setValueAt(greenStandardDeviation, 1, 2);
        table.setValueAt(blueStandardDeviation, 1, 3);
    }

    //Task 5 - Huffman coding (save)
    public void SaveUsingHuffmanSymbols() {

        //generate every probabilities for all levels
        HashMap<Integer, Integer> tempHashMap = new HashMap<Integer, Integer>();

        for (int k = 0; k < 256; k++) {//add 0 to all levels
            tempHashMap.put(k, 0);
        }

        //Count the probabilities
        for (int i = 0; i < imageHeight; i++) {
            for (int j = 0; j < imageWidth; j++) {
                int level = (new Color(image.getRGB(j, i))).getRed();
                tempHashMap.put(level, tempHashMap.get(level) + 1);
            }
        }

        //Create the sorted HuffmanNode arrayList
        ArrayList<HuffmanNode> huffmanNodeArray = new ArrayList<>();
        for (int i = 0; i < 256; i++) {
            int minValue = Integer.MAX_VALUE;
            int keyForMinValue = 0;
            for (HashMap.Entry<Integer, Integer> entry : tempHashMap.entrySet()) {
                int tempValue = entry.getValue();
                if (tempValue < minValue) {
                    minValue = tempValue;
                    keyForMinValue = entry.getKey();
                }
            }

            huffmanNodeArray.add(new HuffmanNode(minValue, keyForMinValue));
            tempHashMap.remove(keyForMinValue);
        }

        /*
        //Pseudo Code
        for(untill length(huffman array) becomes 1){
            create new Node;
            add huffmann[0] and huffmann[1] to its child nodes
            updata its int value = sum of child values
            delete child nodes from the array.
            add parent to the array
            sort HUffmaan array using int value
         */
        HuffmanNode root = null;
        while (huffmanNodeArray.size() > 1) {
            HuffmanNode newNode = new HuffmanNode(huffmanNodeArray.get(0).getProbability() + huffmanNodeArray.get(1).getProbability(), huffmanNodeArray.get(0), huffmanNodeArray.get(1));
            huffmanNodeArray.remove(1);
            for (int i = 1; i < huffmanNodeArray.size(); i++) {
                if (newNode.getProbability() < huffmanNodeArray.get(i).getProbability()) {
                    huffmanNodeArray.set(i - 1, newNode);
                    break;
                } else {
                    huffmanNodeArray.set(i - 1, huffmanNodeArray.get(i));
                    huffmanNodeArray.set(i, newNode);
                }
            }
            root = newNode;
        }

        outputHashMapWithSymbols = new HashMap<Integer, String>();
        GenerateSymbol(root);
        //huffmann code generation is over

        //convert image to a bit array
        BitSet bitsOfImage = new BitSet();
        int bitLength = 0;
        for (int i = 0; i < imageHeight; i++) {
            for (int j = 0; j < imageWidth; j++) {
                int grayLevelKey = (new Color(image.getRGB(j, i))).getRed();
                String currentSymbol = outputHashMapWithSymbols.get(grayLevelKey);
                for (int k = 0; k < currentSymbol.length(); k++) {
                    if ("1".equals(currentSymbol.substring(k, k + 1))) {
                        bitsOfImage.set(bitLength);
                        bitLength++;
                    } else if ("0".equals(currentSymbol.substring(k, k + 1))) {
                        bitsOfImage.clear(bitLength);
                        bitLength++;
                    } else {
                        System.out.println("Something wrong...");
                    }
                }
            }
        }
        byte[] bytesOfImage = bitsOfImage.toByteArray();
        //convertion is over

        int byteLength = (bitLength + 7) / 8;
        /*
        first 8 bytes will show the length and height of the image
        get the max length of the symbols. decide the number of bytes-1 for an entry.
        The 9th byte of the file gives the number of bytes for a one entry of hashMapWithSymbols.
        for an entry first byte will say the number of zeroes infront of the each symbol. rest will gives the symbol with '0's filled in front
        after that next will be a bit pattern. convert the bit pattern in to a byte array.thats all.
         */
        //calculate the maximum length of symbols
        int maxLengthOfSymbols = 0;
        for (int i = 0; i < 256; i++) {
            if (maxLengthOfSymbols < outputHashMapWithSymbols.get(i).length()) {
                maxLengthOfSymbols = outputHashMapWithSymbols.get(i).length();
            }
        }

        int numberOfBytesPerEntry = (maxLengthOfSymbols + 8) / 8;

        //initializing byteArray
        byte[] byteArray = new byte[9 + (256 * (numberOfBytesPerEntry + 1)) + byteLength];

        //store width, height
        byte[] width = ByteBuffer.allocate(4).putInt(imageWidth).array();
        byte[] height = ByteBuffer.allocate(4).putInt(imageHeight).array();
        for (int i = 0; i < 4; i++) {
            byteArray[i] = width[i];
            byteArray[i + 4] = height[i];
        }
        byteArray[8] = (byte) (numberOfBytesPerEntry - 128);

        //store Haffmann code to the byteArray
        int p = 9;
        for (int i = 0; i < 256; i++) {
            String symbolString = outputHashMapWithSymbols.get(i);
            int numberOfZeroesInfrontOfSymbol = 0;
            for (int j = 0; j < symbolString.length(); j++) {
                if ("0".equals(symbolString.substring(j, j + 1))) {
                    numberOfZeroesInfrontOfSymbol++;
                } else {
                    break;
                }
            }

            byteArray[p] = (byte) (numberOfZeroesInfrontOfSymbol - 128);
            byte[] tempSymbolBytes = new BigInteger(symbolString, 2).toByteArray();
            byte[] symbolBytes = new byte[numberOfBytesPerEntry];
            for (int n = 0; n < numberOfBytesPerEntry; n++) {
                if (n < numberOfBytesPerEntry - tempSymbolBytes.length) {
                    symbolBytes[n] = 0;
                } else {
                    symbolBytes[n] = tempSymbolBytes[n - numberOfBytesPerEntry + tempSymbolBytes.length];
                }
            }
            for (int j = 0; j < numberOfBytesPerEntry; j++) {
                byteArray[p + 1 + j] = symbolBytes[j];
            }
            p = p + 1 + numberOfBytesPerEntry;
        }//adding Huffmann code is over

        //add pixels to the byte array.
        for (int i = 0; i < byteLength; i++) {
            byteArray[9 + (256 * (numberOfBytesPerEntry + 1)) + i] = bytesOfImage[i];
        }

        if (filechooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File newImagePath = new File(filechooser.getSelectedFile().toString() + ".130281M");
            try {
                FileOutputStream fos = new FileOutputStream(newImagePath);
                fos.write(byteArray);
                fos.close();
            } catch (IOException ex) {
                Logger.getLogger(Image.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

    }

    //Task 5 - Huffman coding (open)
    public void openHuffmanFormat(Path filePath) {
        try {
            byte[] byteArray = Files.readAllBytes(filePath);
            int width = ByteBuffer.wrap(Arrays.copyOfRange(byteArray, 0, 4)).getInt();
            int height = ByteBuffer.wrap(Arrays.copyOfRange(byteArray, 4, 8)).getInt();
            int numberOfBytesPerEntry = ((int) byteArray[8]) + 128;

            //decode the Haffman table
            HashMap<String, Integer> inputSymbolHashMap = new HashMap<>();

            int p = 9;
            for (int i = 0; i < 256; i++) {
                int numOfZeroesInfront = ((int) byteArray[p]) + 128;

                //create zeroes
                String firstZeroes = "";
                for (int s = 0; s < numOfZeroesInfront; s++) {
                    firstZeroes = "0" + firstZeroes;
                }

                //get values
                int valueOfSecondPart = new BigInteger(Arrays.copyOfRange(byteArray, p + 1, p + numberOfBytesPerEntry + 1)).intValue();

                String secondPart = "";
                if (valueOfSecondPart != 0) {
                    secondPart = Integer.toBinaryString(valueOfSecondPart);
                }

                String symbolKey = firstZeroes + secondPart;
                inputSymbolHashMap.put(symbolKey, i);
                p = p + numberOfBytesPerEntry + 1;
            }

            int tableLength = 9 + (256 * (numberOfBytesPerEntry + 1));
            int[] tempasdf = new int[width * height];
            int indexForTemp = 0;
            String tempString = "";
            int whileIndexThroughByteArray = tableLength;

            while (whileIndexThroughByteArray < byteArray.length) {
                boolean found = false;
                int tempLength = tempString.length();
                for (int index = 1; index < tempLength; index++) {
                    String keyString = tempString.substring(0, index);
                    if (inputSymbolHashMap.containsKey(keyString)) {
                        tempasdf[indexForTemp] = inputSymbolHashMap.get(keyString);
                        indexForTemp++;
                        tempString = tempString.substring(index);
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    tempString = tempString + new StringBuilder(String.format("%8s", Integer.toBinaryString(byteArray[whileIndexThroughByteArray] & 0xFF)).replace(' ', '0')).reverse().toString();
                    whileIndexThroughByteArray++;
                }
            }

            BufferedImage anImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
            for (int i = 0; i < height; i++) {
                for (int j = 0; j < width; j++) {
                    int colour = tempasdf[(width * i) + j];
                    anImage.setRGB(j, i, new Color(colour, colour, colour, 255).getRGB());
                }
            }
            image = anImage;
            drawImage();
        } catch (IOException ex) {
            Logger.getLogger(Image.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    //Task 5 - Huffman coding
    void GenerateSymbol(HuffmanNode node) {
        //if this is a leave of the tree add its symbol and gray level to the hashmap.
        if ((node.getLeft() == null) & (node.getRight() == null)) {
            outputHashMapWithSymbols.put(node.getGrayLevel(), node.getSymbol());
        } //else, update the symbol and call the recursively same function.
        else {
            HuffmanNode left = node.getLeft();
            HuffmanNode right = node.getRight();
            left.setSymbol(node.getSymbol() + "0");
            right.setSymbol(node.getSymbol() + "1");
            GenerateSymbol(left);
            GenerateSymbol(right);
        }
    }

    public void open_tt_files(Path filePath) {
        try {
            open4bytePixel(filePath);
            System.out.println("opening 4 byte format...");
        } catch (ArrayIndexOutOfBoundsException e) {
            try {
                open1bytePixel(filePath);
                System.out.println("opening 1 byte format...");
            } catch (ArrayIndexOutOfBoundsException er) {
                try {
                    openHuffmanFormat(filePath);
                    System.out.println("opening Huffman format...");
                } catch (Exception en) {
                    System.out.println("Error in opening...");
                }
            }
        }
    }

    void drawImage() {
        imageWidth = image.getWidth();
        imageHeight = image.getHeight();
        jLabel1.setSize(imageWidth, imageHeight);
        jLabel1.setIcon(new ImageIcon(image));
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Image.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Image.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Image.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Image.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Image().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton10;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JButton jButton5;
    private javax.swing.JButton jButton6;
    private javax.swing.JButton jButton7;
    private javax.swing.JButton jButton8;
    private javax.swing.JButton jButton9;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTable jTable1;
    private javax.swing.JTable jTable2;
    // End of variables declaration//GEN-END:variables

    public class HuffmanNode {

        int edge;
        int probability;
        int grayLevel;
        String symbol = "";
        HuffmanNode left;
        HuffmanNode right;

        public HuffmanNode(int probability, int grayLevel) {
            this.probability = probability;
            this.grayLevel = grayLevel;
        }

        public HuffmanNode(int probability, HuffmanNode left, HuffmanNode right) {
            this.probability = probability;
            this.left = left;
            this.right = right;
        }

        public int getEdge() {
            return edge;
        }

        public int getProbability() {
            return probability;
        }

        public int getGrayLevel() {
            return grayLevel;
        }

        public String getSymbol() {
            return symbol;
        }

        public HuffmanNode getLeft() {
            return left;
        }

        public HuffmanNode getRight() {
            return right;
        }

        public void setEdge(int edge) {
            this.edge = edge;
        }

        public void setProbability(int probability) {
            this.probability = probability;
        }

        public void setGrayLevel(int grayLevel) {
            this.grayLevel = grayLevel;
        }

        public void setSymbol(String symbol) {
            this.symbol = symbol;
        }

        public void setLeft(HuffmanNode left) {
            this.left = left;
        }

        public void setRight(HuffmanNode right) {
            this.right = right;
        }

    }
}
